# -*- coding: utf-8 -*-
# @File    : {{klass.name}}.py
# @AUTH    : model_creater

import datetime
{% if aio %}
from async_property import async_property
{% endif %}
import document_utils as model
from document_utils.consts import NAME_DICT
from ..models.{{klass.name }} import {{klass.name}} as {{klass.name}}Model
{% if klass.meta.values.get("parent") %}
{% for _klass in app.klass %}
{% if _klass.name == klass.meta.values.get("parent") %}
from .{{_klass.name | title}} import {{_klass.name | title}}
{% endif %}
{% endfor %}
{% else %}
from ...BaseDAO import BaseDAO
{% endif %}
from common.Utils.log_utils import getLogger

log = getLogger("utils/{{ klass.name | lower }}")


{% if klass.meta.values.get("parent") %}
{% for _klass in app.klass %}
{% if _klass.name == klass.meta.values.get("parent") %}
class {{klass.name}}({{_klass.name | title}}):
{% endif %}
{% endfor %}
{% else %}
class {{klass.name}}(BaseDAO):
{% endif %}
{% for field in klass.fields %}
    {% if field.field_type == "datetime" %}
    {{field.name}} = model.DateTimeField({{field|get_utils_params(klass)}})
    {% elif field.field_type == "str" %}
    {{field.name}} = model.StringField({{field|get_utils_params(klass)}})
    {% elif field.field_type == "int" %}
    {{field.name}} = model.IntField({{field|get_utils_params(klass)}})
    {% elif field.field_type == "list" %}
    {{field.name}} = model.ListField({{field|get_utils_params(klass)}})
    {% elif field.field_type == "dict" %}
    {{field.name}} = model.DictField({{field|get_utils_params(klass)}})
    {% elif field.field_type == "boolean" %}
    {{field.name}} = model.BooleanField({{field|get_utils_params(klass)}})
    {% elif field.field_type == "objectid" %}
    {{field.name}} = model.ObjectIdField({{field|get_utils_params(klass)}})
    {% else %}
    {{field.name}} = model.StringField({{field|get_utils_params(klass)}})
    {% endif %}
{% endfor %}

    def __init__(self, **kwargs):
        super({{klass.name}}, self).__init__(**kwargs)

{% for field in klass.fields %}
    {% if field.values.get("ref") %}
    {% if aio %}
    @async_property
    {% else %}
    @property
    {% endif %}
    {% for _klass in app.klass %}
    {% if _klass.name == field.values.get("ref") %}
    {{ 'async ' if aio }}def {{_klass.name | lower}}(self):
        from .{{_klass["name"] | title}} import {{_klass.name | title}}
        return {{ 'await ' if aio }}{{_klass.name | title}}.get_{{_klass.name | lower}}_by_{{_klass.name | lower}}_id(self.{{field.name}})
    {% endif %}
    {% endfor %}
    {% endif %}
{% endfor %}
    @classmethod
    {{ 'async ' if aio }}def get_{{klass.name | lower}}_by_{{klass.name | lower}}_id(cls, {{klass.name | lower}}_id):
        return {{ 'await ' if aio }}cls.select(id={{klass.name | lower}}_id)

{% if klass.meta.values.get("listorder") %}
    {{ 'async ' if aio }}def create(self, **kwargs):
    {% for field in klass.fields %}
        {{field.name}} = {{klass.name}}.first().{{field.name}} + 100000
    {% endfor %}
        {{ 'await ' if aio }} super({{klass.name}}, self).create(**kwargs)

{% endif %}

NAME_DICT[BaseDAO.__manager__]["{{klass.name}}"] = {{klass.name}}Model